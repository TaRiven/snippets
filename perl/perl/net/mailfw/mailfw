#!/usr/local/bin/perl

use Net::SMTP;
use MIME::Parser;
use strict;

# Script scoped vars...
# * configuration
# * files created by MIME::Entity
# * bad parts found during analyze
# * path to the configuration file
my(%conf, @files, @badParts, $conf_file);

$conf_file="mailfw.conf";

# Make sure the mime type is acceptable according to our ``good'' list.
sub checkType
{
	my($type, $eff_type, $ok, @oktypes)=@_;

	# Bring in the list of OK mime types.
	@oktypes=();
	open(IN, "<$conf{'mime_ok'}");
	while(<IN>) {
		next if(/^#/);
		next unless(/\w/);
		chomp;
		push(@oktypes, $_);
	}
	close(IN);

	# Check it against all types.
	$ok=0;
	for(@oktypes) {
		if($type=~/$_/i) {
			$ok=1;
		}
	}
	if($ok==0) {
		die("Type $type is not a known good type.\n");
	}
}

# Verify the name doesn't end with something we know to be bad.
sub checkName
{
	my($name)=@_;
	my(@badnames, $ok);

	# This is an autogenerated name, ignore it.
	return if($name=~/auto_generated-$$/);

	# Pull in the list of bad extensions.
	@badnames=();
	open(IN, "<$conf{'ext_bad'}");
	while(<IN>) {
		next if(/^#/);
		next unless(/\w/);
		chomp;
		push(@badnames, $_);
	}
	close(IN);

	$ok=1;
	for(@badnames) {
		if($name=~/$_$/i) {
			$ok=0;
			last; # No need to keep looking, we know it's bad.
		}
	}
	if($ok==0) {
		die("File $name does not have an acceptable name.\n");
	}
}

# Analyze an entity recursively to make sure all the parts are OK.  If the
# current entity is good, returns it, else returns nothing.
sub analyze
{
	my($entity)=@_;
	my($type, $name, $eff_type, @tmp, $bad);

	# Figure out the types and effective types
	$type=$entity->mime_type;
	$eff_type=$entity->effective_type;
	$name=($entity->bodyhandle ? $entity->bodyhandle->path : "undef");

	# List this as a file that needs to be removed before we exit.
	unless($name eq "undef") {
		push(@files, $name);
	}

	# Do the verifications.
	eval {
		checkType($type, $eff_type);
		checkName($name);
	};

	# If it's bad, mark it as such.
	if($@) {
		push(@badParts, [$name, $type, "$@"]);
		$bad=1;
	} else {
		$bad=0;
	}

	# Create the list of entities to replace our current entity list with.
	@tmp=();
	for(0..($entity->parts-1)) {
		push(@tmp, analyze($entity->parts($_)));
	}

	# Replace the list.
	$entity->parts(\@tmp);

	# Figure out how much to return
	if($bad==1) {
		@tmp=();
	} else {
		@tmp=($entity);
	}

	return(@tmp);
}

# Quick and easy way to send a message.
sub sendMessage
{
	my($to, $from, @msg)=@_;

	my $smtp=Net::SMTP->new($conf{'mail_server'})
		|| die("Error instantiating SMTP");
	$smtp->mail($from) || die("Sender error");
	$smtp->to($to) || die("Recipient error");
	$smtp->data(@msg) || die("Data error");
	$smtp->dataend() || die("End data error");
	$smtp->quit();
}

# Process exit, remove temporary files.
sub do_exit
{
	my($status)=@_;
	for(@files) {
		unlink($_);
	}
	exit($status);
}

sub save_msg
{
	my($to, $file)=@_;
	my($t);
	# Make the directory, if it's already there, great, create it again!
	mkdir("$conf{mailstore}/$to", 0700);
	$t=time();
	open(F, ">$conf{mailstore}/$to/$t.$$");
	print F <$file>;
	close(F);
}

############
## Beginning
############

# Open and load the configuration
open(IN, "<$conf_file");
while(<IN>) {
	next if(/^#/);
	next unless(/\w/);
	chomp;
	my(@a)=split(/\s*=\s*/, $_, 2);
	$conf{$a[0]}=$a[1];
}
close(IN);

# Get the to and the from from the ARGV
my($from, $to)=@ARGV;
my $parser=MIME::Parser->new;

$parser->output_dir($conf{'tmpdir'});
$parser->output_prefix("auto_generated");

# Save to a tmpfile
my $tmpfile=IO::File->new_tmpfile();
print $tmpfile <STDIN>;

# Rewind
$tmpfile->seek(0, 0);
# Save a copy
save_msg($to, $tmpfile);
# Rewind again
$tmpfile->seek(0, 0);
# parse
my $entity=$parser->read($tmpfile);
# Rewind again, if it's OK, we'll just use this file for our SMTP input.
$tmpfile->seek(0, 0);

# Get entity object with whatever parts analyze wanted to remove.
($entity)=analyze($entity);

# We're done with our analysis and fixups on the message, let's send it.
eval {
	# If we had badParts, we need to tell the user about them.
	if(@badParts) {

		# this message contained bad parts...generate our own chunk of text
		# describing what we did, and stick it in the front of the good
		# parts.

		my $text="This message contained nasty attachments that have been\n"
			."removed for your protection.  "
			."The following items were removed:\n\n";

		for(@badParts) {
			my $n=$_->[0];
			$n=~s/^$conf{'tmpdir'}\/(.*)/$1/;
			$text.="\t$n ($_->[1])\n\t\t$_->[2]\n";
		}

		$text.="-- Ops\n";

		my($e2)=MIME::Entity->build('Type' => 'text/plain',
			'Encoding' => 'quoted-printable',
			'Data' => $text);

		my(@parts)=($e2, $entity->parts());
		$entity->parts(\@parts);

		# Add our headers, and sync everything up.
		my $head = $entity->head;
		$head->add('X-Firewalled', 'Portions removed');
		$entity->head($head);
		$entity->sync_headers(Length=>'COMPUTE');

		sendMessage($to, $from,
			$entity->stringify_header(), $entity->stringify_body());
		if( defined($conf{'rejects_to'}) && $conf{'rejects_to'}=~/\w/) {
			sendMessage($conf{'rejects_to'}, $from,
				$entity->stringify_header(), $entity->stringify_body());
		}
	} else {
		# It was good, just send the message as it came to us.
		sendMessage($to, $from, <$tmpfile>);
	}
};

# If the above eval fails, try again later.
if($@) {
	print STDERR "Error processing SMTP stuff.\n";
	# EX_TEMPFAIL
	do_exit(75);
}

# EX_OK
do_exit(0);
